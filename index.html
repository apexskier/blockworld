<!DOCTYPE html>
<head>
    <meta name="viewport" content="width=device-width,user-scalable=no">
    <title> </title>
    <style>
        canvas { width: 100%; height: 100% }
        body {
            margin: 0;
        }
    </style>
</head>
<body>
    <canvas id="main"></canvas>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/three.js/r68/three.js"></script>
    <script src="https://cdn.socket.io/socket.io-1.1.0.js"></script>
    <script type="text/javascript">
        // constants
        const MOUSE_SENSITIVITY = 5; // higher is less sensitive

var socket = io.connect();

var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

var canvas = document.getElementById("main");
var renderer = new THREE.WebGLRenderer({
    canvas: canvas
});
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );

var geometry = new THREE.BoxGeometry(1,1,1);
var material = new THREE.MeshLambertMaterial( { color: 0x00ff00 } );
var cube = new THREE.Mesh( geometry, material );
var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.6 );
directionalLight.position.set( 1, 1, 1 ).normalize();
var ambientLight = new THREE.AmbientLight(0x777777);

scene.add( cube );
scene.add( directionalLight );
scene.add( ambientLight );

var objects = {}

camera.position.z = 5;
camera.rotation.order = 'ZXY';

socket.on('connect', function(msg) {
    console.log("connected to ws");
    var now = new Date();
    socket.emit('ping', {});
    socket.on('pong', function(msg) {
        console.log('pong');
        console.log(new Date() - now);
    });

    socket.on('add', function(msg) {
        console.log('add');
        console.log(msg);
        var material = new THREE.MeshLambertMaterial( { color: msg.color } );
        objects[msg.id] = new THREE.Mesh( geometry, material );
        console.log(objects);
        console.log(msg.id);
        var o = objects[msg.id]
        if (msg.hasOwnProperty('position')) {
            o.position.x = msg.position.x;
            o.position.y = msg.position.y;
            o.position.z = msg.position.z;
        } else {
            o.position.z = 3;
        }
        o.rotation.order = 'ZYX';
        scene.add(o);
    });

    socket.on('remove', function(msg) {
        console.log('remove');
        scene.remove(objects[msg.id]);
        delete objects[msg.id];
    });

    socket.on('move', function(msg) {
        if (objects.hasOwnProperty(msg.id)) {
            var o = objects[msg.id];
            if (msg.hasOwnProperty('position')) {
                if (msg.position.hasOwnProperty('x')) {
                    o.position.x = msg.position.x;
                }
                if (msg.position.hasOwnProperty('y')) {
                    o.position.y = msg.position.y;
                }
                if (msg.position.hasOwnProperty('z')) {
                    o.position.z = msg.position.z;
                }
            }
            if (msg.hasOwnProperty('rotation')) {
                if (msg.rotation.hasOwnProperty('x')) {
                    o.rotation.x = msg.rotation.x;
                }
                if (msg.rotation.hasOwnProperty('y')) {
                    o.rotation.y = msg.rotation.y;
                }
                if (msg.rotation.hasOwnProperty('z')) {
                    o.rotation.z = msg.rotation.z;
                }
            }
        }
    });
});

var radFactor = Math.PI / 180;
var device = {
    base: {
        x: 0,
        y: 0,
        z: 0
    }
};

if (typeof window.DeviceOrientationEvent != "undefined") {
    window.addEventListener("deviceorientation", handleOrientationInit, true);
    function handleOrientationInit(e) {
        //device.base.x = -e.beta * radFactor;
        console.log(device.base.x);
        window.removeEventListener("deviceorientation", handleOrientationInit, true);
        window.addEventListener("deviceorientation", handleOrientation, true);
    }

    function handleOrientation(e) {
        device.absolute = event.absolute;
        device.x = e.beta * radFactor;    // 0 to 360     x
        device.y = e.gamma * radFactor;   // -180 to 180  y
        device.z = e.alpha * radFactor;   // -90 to 90    z

        camera.rotation.x = device.base.x + device.x;
        camera.rotation.y = device.base.y + device.y;
        camera.rotation.z = device.base.z + device.z;
    }
}

/*
window.addEventListener("orientationchange", setOrientation, false);
function setOrientation() {
    if (window.orientation == 0) {
        camera.rotation.order = 'ZXY';
    } else if (window.orientation == 90) {
        camera.rotation.order = 'XYZ';
    }
}
setOrientation();
*/

var clicking = false;
var mousePos = {};
var base = {
    rotation: {},
    position: {}
};
var change = {
    position: {
        x: 0,
        y: 0,
        z: 0
    },
    rotation: {
        x: 0,
        y: 0,
        z: 0
    }
};

var height = document.documentElement.clientHeight;

window.addEventListener("touchstart", function(e) {
    if (e.touches[0].clientY < 0.4 * height) {
        placeObject();
    } else {
        if (e.touches.length == 2) {
            change.position.z = -0.1;
        } else if (e.touches.length == 1) {
            change.position.z = 0.1;
        } else {
            change.position.z = 0;
        }
    }
});
window.addEventListener("touchend", function(e) {
    change.position.z = 0;
});

canvas.onclick = function() {
    canvas.requestPointerLock();
}
document.addEventListener('pointerlockchange', lockChangeAlert, false);
document.addEventListener('mozpointerlockchange', lockChangeAlert, false);
document.addEventListener('webkitpointerlockchange', lockChangeAlert, false);
function lockChangeAlert() {
    if (document.pointerLockElement === canvas ||
            document.mozPointerLockElement === canvas ||
            document.webkitPointerLockElement === canvas) {
        console.log('The pointer lock status is now locked');
        document.addEventListener("mousemove", handleMouseMove, false);
    } else {
        console.log('The pointer lock status is now unlocked');
        document.removeEventListener("mousemove", handleMouseMove, false);
    }
}
function handleMouseMove(e) {
    var movementX = e.movementX ||
        e.mozMovementX          ||
        e.webkitMovementX       ||
        0;
    var movementY = e.movementY ||
        e.mozMovementY      ||
        e.webkitMovementY   ||
        0;
    camera.rotateY(movementX * radFactor / MOUSE_SENSITIVITY);
    camera.rotateX(movementY * radFactor / MOUSE_SENSITIVITY);
}

window.addEventListener("keydown", function(e) {
    switch (e.keyCode) {
        case 87: // W
            change.position.z = 0.1;
            break;
        case 83: // S
            change.position.z = -0.1;
            break;
        case 65: // A
            change.position.x = -0.1;
            break;
        case 68: // D
            change.position.x = 0.1;
            break;
        case 37: // <-
            change.rotation.y = 3 * radFactor;
            e.preventDefault();
            break;
        case 39: // ->
            change.rotation.y = -3 * radFactor;
            e.preventDefault();
            break;
        case 38: // up
            change.rotation.x = 3 * radFactor;
            break;
        case 40: // down
            change.rotation.x = -3 * radFactor;
            break;
        default:
            break;
    }
});
window.addEventListener("keyup", function(e) {
    switch (e.keyCode) {
        case 87: // W
        case 83: // S
            change.position.z = 0;
            break;
        case 65: // A
        case 68: // D
            change.position.x = 0;
            break;
        case 37: // <-
        case 39: // ->
            change.rotation.y = 0;
            break;
        case 38: // up
        case 40: // down
            change.rotation.x = 0;
            break;
        case 32: // <space>
            placeObject();
        default:
            break;
    }
});

function placeObject() {
    var objectplace = new THREE.Vector3();
    objectplace.copy(camera.position)
    objectplace.add(new THREE.Vector3( 0, 0, -1 ).applyQuaternion(camera.quaternion).normalize().multiplyScalar(3));
    socket.emit('place', {
        position: {
            x: objectplace.x,
            y: objectplace.y,
            z: objectplace.z
        }
    });
}

function render() {
    requestAnimationFrame(render);

    cube.rotation.x += 0.01;
    cube.rotation.y += 0.01;

    camera.translateZ(-change.position.z);
    camera.translateX(change.position.x);
    camera.rotateX(change.rotation.x);
    camera.rotateY(change.rotation.y);

    socket.emit('move', {
        rotation: {
            x: camera.rotation.x,
            y: camera.rotation.y,
            z: camera.rotation.z
        },
        position: {
            x: camera.position.x,
            y: camera.position.y,
            z: camera.position.z
        }
    });

    renderer.render(scene, camera);
}
render();
    </script>
</body>
</html>
